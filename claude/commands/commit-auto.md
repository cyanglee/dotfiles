# Claude Command: Atomic Commit Generation

## Primary Goal
To create a single, atomic, and deployable commit for a logical unit of work, with files organized by functionality and temporal sequence.

## Core Rule: Group by Functionality and Time Order
A commit must group all related file changes that constitute a single, complete logical feature or fix. Files should be staged based on:
1. Functional Relationship: All files that work together to implement a feature
2. Temporal Sequence: Order files by when they should be applied (e.g., migrations before models, models before controllers)

The resulting commit should leave the application in a working, deployable state where all tests pass.

DO: Commit related models, views, controllers, tests, and migrations together in logical order.
DO: Stage files in dependency order: database migrations → models → controllers → views → tests.
DO NOT: Mix unrelated changes (e.g., a user feature and a product fix) in one commit.
DO NOT: Separate layers of the same feature into different commits (e.g., a migration in one commit, and the model using it in another).

## Staging and Committing Workflow
1. Identify a single logical change (e.g., "add user preferences", "fix authentication bug").
2. Selectively stage all files related to that change. Use `git add <file1> <file2> ...`.
3. Review the staged files. Use `git diff --staged` to ensure only related files are included.
4. Write the commit message. Follow the format below.

### AI-Assisted Workflow

As your AI assistant, I will help you follow these guidelines by automating the staging, message generation, and verification steps.

1. Automatic File Staging: I will analyze your modified files and group them by functionality and temporal sequence. Files will be staged in dependency order (migrations → models → controllers → views → tests).

2. Commit Message Generation: I will generate a commit message following the `type(scope): description` format without any markdown syntax or generated-by footers.

3. Pre-Commit Verification: I will run tests to ensure the commit leaves the codebase in a working state.

#### Example Interaction

You:
> @claude commit my changes for the new user preferences feature.

Me:
> I see you've modified the following files (grouped by functionality and ordered by temporal sequence):
> 
> Database layer:
> - `db/migrate/20250716123456_add_preferences_to_users.rb`
> 
> Model layer:
> - `app/models/user.rb`
> 
> Controller layer:
> - `app/controllers/users_controller.rb`
> 
> Tests:
> - `spec/models/user_spec.rb`
>
> These files will be staged in this order. Shall I proceed?

(You approve)

Me:
> Files staged. Suggested commit message:
>
> `feat(users): add user preferences feature`
>
> Would you like to use this message?

(You approve)

Me:
> Running tests...
> All tests passed.
>
> Commit successful!

## Commit Message Format (Conventional Commits)

Format: `type(scope): description`

The `type` must be one of:
- `feat`: A new feature
- `fix`: A bug fix
- `refactor`: Code changes that neither fix a bug nor add a feature
- `test`: Adding missing tests or correcting existing tests
- `docs`: Documentation only changes
- `style`: Changes that do not affect the meaning of the code (white-space, formatting, etc)
- `chore`: Changes to the build process or auxiliary tools
- `perf`: A code change that improves performance
- `ci`: Changes to our CI configuration files and scripts

The `scope` should describe the area of the codebase you changed (e.g., `models`, `auth`, `api`, `components`, `db`).

The `description` is a short, imperative summary of the change.

### Message Rules
- NO markdown syntax (like `**` or `` ` ``).
- Use imperative mood in the description (e.g., "add feature" not "added feature").
- For multiple distinct changes within one commit, use a body with bullet points.
- NO "generated by", "Co-Authored-By", or ANY footers/annotations.

### Examples

Good (Single Line):
```
feat(models): add user preferences with validations
fix(api): handle null response from user endpoint
style(components): improve button spacing
refactor(auth): extract session management logic
```

Good (With Body):
```
feat(auth): implement user session management

- Add login/logout API endpoints
- Create session handling middleware
- Update user model to include session tokens
```

Good (Functional Grouping with Time Order):
```bash
# Staging files in dependency order
git add db/migrate/xxx_add_preferences_to_users.rb
git add app/models/user.rb
git add app/controllers/users_controller.rb
git add spec/models/user_spec.rb
# Commit
git commit -m "feat(users): implement user preferences feature"
```

Bad (Mixing Concerns):
```bash
# Staging unrelated files
git add app/models/user.rb app/models/product.rb
# This should be two separate commits.
```

Bad (Wrong Message Format):
```bash
# Including generated-by footers
git commit -m "feat(users): add preferences

Generated with Claude Code
Co-Authored-By: AI Assistant"
# NO footers or annotations allowed
```